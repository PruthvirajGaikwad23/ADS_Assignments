1.Adjacency List 

#include<stdio.h>
#include<stdlib.h>

int queue[50],front = -1,rear = -1;
int stack[50],top = -1;

typedef struct node
{
    int vertex;
    struct node *next;
}node;

node *A[10];

void BFS(node* [],int);
void DFS(node* [],int);
int dequeue();
int queue_empty();
void push(int);
int pop();
int stack_empty();

void push(int x)
{
    if(top == -1)
    {
        top++;
        stack[top] = x;
    }
    else
    {
        top++;
        stack[top] = x;
    }
}

int pop()
{
    if(top == -1)
    {
        printf("\nStack is empty");
        return -1;
    }
    else
    {
        int x = stack[top];
        top--;
        return x;
    }
}

int stack_empty()
{
    return (top == -1);
}

void enqueue(int x)
{
    if(front == -1 && rear == -1)
    {
        front++;
        rear++;
        queue[rear] = x;
    }
    else
    {
        rear++;
        queue[rear] = x;
    }
}

int dequeue()
{
    if(front == -1 && rear == -1)
    {
        printf("\nQueue is Empty");
        return -1;  // Return a value indicating an empty queue
    }
    else
    {
        int temp = queue[front];
        front++;
        if(front > rear)  // Reset queue if all elements are dequeued
        {
            front = rear = -1;
        }
        return temp;
    }
}

int queue_empty()
{
    return (front == -1 && rear == -1);
}

void BFS(node *A[],int V)
{
    node *p;
    int visited[10],st,u;
    for(int i=0;i<V;i++)
        visited[i] = 0;
    printf("\nEnter Starting vertex");
    scanf("%d",&st);
    visited[st] = 1;
    enqueue(st);
    while(!queue_empty())
    {
        u = dequeue();
        printf("%d ",u);
        p = A[u];
        while(p !=NULL)
        {
            if(visited[p->vertex] == 0)
            {
                enqueue(p->vertex);
                visited[p->vertex] = 1;
            }
            p = p->next;
        }
    }
}

void DFS(node *A[],int V)
{
    int visited[10],u,st;
    node *p;
    for(int i=0;i<V;i++)
        visited[i] = 0;
    printf("\nEnter starting vertex");
    scanf("%d",&st);
    visited[st] = 1;
    push(st);
    printf("%d",st);
    p = A[u];
    while(!stack_empty())
    {
        p = A[u];
        while(p != NULL)
        {
            if(visited[p->vertex] == 0)
            {
                push(p->vertex);
                visited[p->vertex] = 1;
                printf("%d ",p->vertex);
                u = p->vertex;
                break;
            }
            else
            {
                p = p->next;
            }
            if(p == NULL)
            {
                pop();
                u = stack[top];
            }
        }
    }
}

int main()
{
    char ch = 'y';
    node *p,*newu,*newv;
    int V,u,v;
    printf("\nEnter number of vertex: ");
    scanf("%d",&V);
    for(int i=0;i<V;i++)
        A[i] = NULL;
    do
    {
        printf("\nEnter edge");
        scanf("%d%d",&u,&v);
        newu = (node*)malloc(sizeof(node));
        newu->vertex = v;
        newu->next = NULL;
        p = A[u];
        if(p == NULL)
            A[u] = newu;
        else
        {
            while(p->next != NULL)
                p = p->next;
            p->next = newu;
        }
        newv = (node*)malloc(sizeof(node));
        newv->vertex = u;
        newv->next = NULL;
        p = A[v];
        if(p == NULL)
            A[v] = newu;
        else
        {
            while(p->next != NULL)
                p = p->next;
            p->next = newv;
        }
        printf("\nAdd more edges (y/n)");
        scanf("%c",&ch);
    }while(ch == 'y');
    do 
    {
        printf("\n\n1)BFS\n2)DFS\n3)Exit\n");
        printf("\nEnter your choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: BFS(A,V);
                    break;
            case 2: DFS(A,V);
                    break;
            case 3: break;
            default:printf("\nWrong input");
                    break;
        }
    }while(ch != 3);
    return 0;
}


2.Adjacency Matrix
#include<stdio.h>
#include<stdlib.h>

int queue[50],front = -1,rear = -1;
int stack[50],top = -1;

void BFS(int [][10],int);
void DFS(int [][10],int);
void enqueue(int);
int dequeue();
int queue_empty();
void push(int);
int pop();
int stack_empty();

void push(int x)
{
    if(top == -1)
    {
        top++;
        stack[top] = x;
    }
    else
    {
        top++;
        stack[top] = x;
    }
}

int pop()
{
    if(top == -1)
    {
        printf("\nStack is empty");
        return -1;
    }
    else
    {
        int x = stack[top];
        top--;
        return x;
    }
}

int stack_empty()
{
    return (top == -1);
}

void enqueue(int x)
{
    if(front == -1 && rear == -1)
    {
        front++;
        rear++;
        queue[rear] = x;
    }
    else
    {
        rear++;
        queue[rear] = x;
    }
}

int dequeue()
{
    if(front == -1 && rear == -1)
    {
        printf("\nQueue is Empty");
        return -1;  // Return a value indicating an empty queue
    }
    else
    {
        int temp = queue[front];
        front++;
        if(front > rear)  // Reset queue if all elements are dequeued
        {
            front = rear = -1;
        }
        return temp;
    }
}

int queue_empty()
{
    return (front == -1 && rear == -1);
}

void BFS(int G[][10],int V)
{
    int visited[10],st,u;
    for(int i=0;i<V;i++)
        visited[i] = 0;
    printf("\nEnter starting vertex");
    scanf("%d",&st);
    visited[st] = 1;
    enqueue(st);
    while(!queue_empty())
    {
        u = dequeue();
        printf("%d ",u);
        for(int i=0;i<V;i++)
        {
            if(G[u][i] == 1 && visited[i] == 0)
            {
                enqueue(i);
                visited[i] = 1;
            }
        }
    }
}

void DFS(int G[][10],int V)
{
    int visited[10],u,st,i;
    for(i=0;i<V;i++)
        visited[i] = 0;
    printf("\nEnter starting vertex");
    scanf("%d",&st);
    push(st);
    printf("%d ",st);
    visited[st] = 1;
    u = st;
    while(!stack_empty())
    {
        for(i=0;i<V;i++)
        {
            if(G[u][i] == 1 && visited[i] == 0)
            {
                push(i);
                visited[i] = 1;
                printf("%d ",i);
                u = i;
                break;
            }
        }
        if(i == V)
        {
            pop();
            u = stack[top];
        }
    }
}

int main()
{
    int G[10][10],V,e,u,v,ch;
    printf("Enter number of vertex");
    scanf("%d",&V);
    for(int i=0;i<V;i++)
    {
        for(int j=0;j<V;j++)
            G[i][j] = 0;
    }
    printf("\nEnter number of edges");
    scanf("%d",&e);
    for(int i=0;i<e;i++)
    {
        printf("\nEnter Edge: ");
        scanf("%d%d",&u,&v);
        G[u][v] = G[v][u] = 1;
    }
    printf("\n\n1)BFS\n2)DFS");
    printf("\nEnter choice");
    scanf("%d",&ch);
    switch(ch)
    {
        case 1: BFS(G,V);
                break;
        case 2: DFS(G,V);
                break;
        default:printf("\nWrong Choice");
                break;
    }
    return 0;
}

3. AVL
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int key;
    struct Node *right;
    struct Node *left;
    int height;
};

int height(struct Node *N) {
    if (N == NULL)
        return 0;
    return N->height;
}

int max(int a, int b) {
    return (a > b) ? a : b;
}

struct Node *newNode(int key) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->height = 1;
    return newNode;
}

struct Node *rightRotate(struct Node *y) {
    struct Node *x = y->left;
    struct Node *T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

struct Node *leftRotate(struct Node *x) {
    struct Node *y = x->right;
    struct Node *T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    return y;
}

struct Node *insert(struct Node *node, int key) {
    if (node == NULL)
        return (newNode(key));

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else
        return node;

    node->height = 1 + max(height(node->left), height(node->right));

    int balance = height(node->left) - height(node->right);

    if (balance > 1 && key < node->left->key)
        return rightRotate(node);

    if (balance < -1 && key > node->right->key)
        return leftRotate(node);

    if (balance > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    if (balance < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

void preOrder(struct Node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        preOrder(root->left);
        preOrder(root->right);
    }
}

void displayMenu() {
    printf("\n\nAVL Tree Menu\n");
    printf("1. Insert a node\n");
    printf("2. Create AVL Tree\n");
    printf("3. Display AVL Tree (Preorder)\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct Node *root = NULL;
    int choice, key;

    do {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter key to insert: ");
                scanf("%d", &key);
                root = insert(root, key);
                break;
            case 2:
                // Optional: You can implement code here to create AVL tree
                break;
            case 3:
                printf("Preorder traversal of the AVL tree is:\n");
                preOrder(root);
                printf("\n");
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice. Please enter a valid option.\n");
        }

    } while (choice != 4);

    return 0;
}

4. BST
#include<stdio.h>
#include<stdlib.h>

typedef struct node
{
    int data;
    struct node *left, *right;
}node;

typedef struct stack
{
    node *T;
    struct stack *next;
}stack;

typedef struct queue
{
    node *T;
    struct queue *next;
}queue;

node* create(node *);
node* insert(node*,int);
void inorder(node*);
void preorder(node*);
void postorder(node*);
int height(node*);
node* delete(node*,int);
node* findmin(node*);
void push(node *, stack**);
node* pop(stack**);
int empty_stack(stack *);
node* top_stack(stack **);
void stack_inorder(node*);
void stack_preorder(node*);
void stack_postorder(node*);
void mirror(node*);
void enqueue(node*,queue**);
node* dequeue(queue**);
void level_BST(node*);
int empty_queue(queue *); 

void level_BST(node *root)
{
    if (root == NULL)
        return;
    queue (*top_q) = NULL;
    enqueue(root, &top_q);
    while (!empty_queue(top_q))
    {
        root = dequeue(&top_q);
        printf("%d ", root->data);
        if (root->left != NULL)
            enqueue(root->left, &top_q);
        if (root->right != NULL)
            enqueue(root->right, &top_q);
    }
}

int empty_queue(queue *top_q)
{
    if(top_q == NULL) 
    return 1;
    return 0;
}

void enqueue(node *root, queue **top_q)
{
    queue *temp = (queue*)malloc(sizeof(queue));
    temp->T = root;
    temp->next = NULL;
    if ((*top_q) == NULL)
    {
        (*top_q) = temp;
    }
    else
    {
        queue *current = (*top_q);
        while (current->next != NULL)
        {
            current = current->next;
        }
        current->next = temp;
    }
}

node* dequeue(queue **top_q)
{
    if ((*top_q) == NULL)
        return NULL;
    queue *temp = (*top_q);
    (*top_q) = (*top_q)->next;
    node *n = temp->T;
    free(temp);
    return n;
}

void mirror(node *root)
{
    stack *top = NULL;
    node *temp,*p;
    p = root;
    push(p,&top);
    while(!empty_stack(top))
    {
        p = pop(&top);
        temp = p->left;
        p->left = p->right;
        p->right = temp;
        if(p->right != NULL)
            push(p->right,&top);
        else if(p->left != NULL)
            push(p->left,&top);
    }
    printf("\nMirror image = ");
    stack_inorder(root);
}

void push(node *root,stack **top)
{
    stack *temp = (stack*)malloc(sizeof(stack));
    temp->T = root;
    temp->next = (*top);
    (*top) = temp;
}

node* pop(stack **top)
{
    stack *temp;
    node *n;
    temp = (*top);
    (*top) = (*top)->next;
    n = temp->T;
    free(temp);
    return n;
}

int empty_stack(stack *top)
{
    if(top == NULL) 
    return 1;
    return 0;
}

node* top_stack(stack **top)
{
    return ((*top)->T);
}

void stack_inorder(node *root)
{
    stack *top = NULL;
    while(root != NULL)
    {
        push(root,&top);
        root = root->left;
    }
    while(!empty_stack(top))
    {
        root = pop(&top);
        printf("%d ",root->data);
        root = root->right;
        while(root != NULL)
        {
            push(root,&top);
            root = root->left;
        }
    }
}

void stack_preorder(node* root)
{
    stack *top = NULL;
    while(root != NULL)
    {
        printf("%d ",root->data);
        push(root,&top);
        root = root->left;
    }
    while(!empty_stack(top))
    {
        root = pop(&top);
        root = root->right;
        while(root != NULL)
        {
            printf("%d ",root->data);
            push(root,&top);
            root = root->left;
        }
    }
}

void stack_postorder(node *root)
 {   
    if(root == NULL)
        return;
    node *prev = NULL;
    stack *top = NULL;
    node *T = root;
    
    do {	
        while (T != NULL) {
            push(T, &top);
            T = T -> left;
        }

        while (T == NULL && !empty_stack(top)) {
            T = top_stack(&top);

            if (T -> right == NULL || T -> right == prev) {
                printf("%d ", T -> data);
                pop(&top);
                prev = T;
                T = NULL; 
            } else {
                T = T -> right;
            }
        }
    } while (!empty_stack(top));
}

node* delete(node *root, int n)
{
    node *temp;
    if(root == NULL)
    {
        return root;
    }
    else if(n > root->data)
        root->right = delete(root->right,n);
    else if(n < root->data)
        root->left = delete(root->left,n);
    else
    {
        if(root->right == NULL)
        {
            temp = root->left;
            free(root);
            return temp;
        }
        else if(root->left == NULL)
        {
            temp = root->right;
            free(root);
            return temp;
        }
        else
        {
            temp = findmin(root->right);
            root->data = temp->data;
            root->right = delete(root->right, temp->data);
        }
    }
    return root;
}

node* findmin(node *root)
{
    node* temp = root;
    while(temp->left != NULL)
        temp = temp->left;
    return temp;
}

node* create(node *root)
{
    int ch,n;
    do
    {
        printf("\n1)Add\n2)Exit");
        printf("\nEnter Choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: printf("\nEnter number");
                    scanf("%d",&n);
                    root = insert(root,n);
                    break;
            case 2: break;
            default:printf("\nWrong choice");
                    break;
        }
    }while(ch != 2);
    return root;
}

node* insert(node *root, int n)
{
    if(root == NULL)
    {
        root = (node*)malloc(sizeof(node));
        root->data = n;
        root->right = NULL;
        root->left = NULL;
        return root;
    }
    else if(n>root->data)
    {
        root->right = insert(root->right,n);
    }
    else
    {
        root->left = insert(root->left,n);
    }
    return root;
}

void inorder(node *root)
{
    if(root != NULL)
    {
        inorder(root->left);
        printf("%d ",root->data);
        inorder(root->right);
    }
}

void preorder(node *root)
{
    if(root != NULL)
    {
        printf("%d ",root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

void postorder(node *root)
{
    if(root != NULL)
    {
        postorder(root->left);
        postorder(root->right);
        printf("%d ",root->data);
    }
}

int height(node *root)
{
    if(root == NULL)
    {
        return -1; // Return -1 to denote that empty tree has height -1
    }
    else
    {
        int left_height = height(root->left);
        int right_height = height(root->right);
        return (left_height > right_height ? left_height : right_height) + 1;
    }
}

int main()
{
    node *root = NULL;
    int ch,n;
    do
    {
        printf("\n\n1)Create\n2)Insert\n3)Inorder\n4)Preorder\n5)Postorder\n6)Height\n7)Delete\n8)Non-Recursive Inorder\n9)Non-Recursive Preorder\n10)Non-Recursive Postorder\n11)Mirror\n12)Level_BST\n13)Exit\n");
        printf("\nEnter Choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: root = create(root);
                    break;
            case 2: printf("\n\nEnter data");
                    scanf("%d",&n);
                    root = insert(root,n);
                    break;
            case 3: inorder(root);
                    break; 
            case 4: preorder(root);
                    break;
            case 5: postorder(root);
                    break;
            case 6: printf("\nHeight= %d",height(root));
                    break;
            case 7: printf("\nEnter node to be deleted: ");
                    scanf("%d",&n);
                    root = delete(root,n);
                    break;
            case 8: stack_inorder(root);
                    break;
            case 9: stack_preorder(root);
                    break;
            case 10:stack_postorder(root);
                    break;
            case 11:mirror(root);
                    break;
            case 12:level_BST(root);
                    break;
            case 13:break;
            default:printf("\nwrong choice");
                    break;
        }
    }while(ch!=12);
    return 0;
}


5.Circular Linked List

#include <stdio.h>
#include <stdlib.h>

#define MAX 100

typedef struct {
    int arr[MAX];
    int front;
    int rear;
    int size;
} queue;

// Initialize the queue
void initqueue(queue* q) {
    q->front = -1;
    q->rear = -1;
    q->size = 0;
}

// Check if the queue is full
int isFull(queue* q) {
    return q->size == MAX;
}

// Check if the queue is empty
int isEmpty(queue* q) {
    return q->size == 0;
}

// Insert element at the front
void insertFront(queue* q, int value) {
    if (isFull(q)) {
        printf("queue is full\n");
        return;
    }
    if (isEmpty(q)) {
        q->front = 0;
        q->rear = 0;
    } else {
        q->front = (q->front - 1 + MAX) % MAX;
    }
    q->arr[q->front] = value;
    q->size++;
}

// Insert element at the rear
void insertRear(queue* q, int value) {
    if (isFull(q)) {
        printf("queue is full\n");
        return;
    }
    if (isEmpty(q)) {
        q->front = 0;
        q->rear = 0;
    } else {
        q->rear = (q->rear + 1) % MAX;
    }
    q->arr[q->rear] = value;
    q->size++;
}

// Delete element from the front
int deleteFront(queue* q) {
    if (isEmpty(q)) {
        printf("queue is empty\n");
        return -1;
    }
    int value = q->arr[q->front];
    if (q->front == q->rear) {
        q->front = -1;
        q->rear = -1;
    } else {
        q->front = (q->front + 1) % MAX;
    }
    q->size--;
    return value;
}

// Delete element from the rear
int deleteRear(queue* q) {
    if (isEmpty(q)) {
        printf("queue is empty\n");
        return -1;
    }
    int value = q->arr[q->rear];
    if (q->front == q->rear) {
        q->front = -1;
        q->rear = -1;
    } else {
        q->rear = (q->rear - 1 + MAX) % MAX;
    }
    q->size--;
    return value;
}

// Display the queue
void displayqueue(queue* q) {
    if (isEmpty(q)) {
        printf("queue is empty\n");
        return;
    }
    printf("queue elements: ");
    int i = q->front;
    for (int count = 0; count < q->size; count++) {
        printf("%d ", q->arr[i]);
        i = (i + 1) % MAX;
    }
    printf("\n");
}

int main() {
    queue q;
    initqueue(&q);

    int choice, value;
    while (1) {
        printf("\n1. Insert Front\n2. Insert Rear\n3. Delete Front\n4. Delete Rear\n5. Display queue\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert at front: ");
                scanf("%d", &value);
                insertFront(&q, value);
                break;
            case 2:
                printf("Enter value to insert at rear: ");
                scanf("%d", &value);
                insertRear(&q, value);
                break;
            case 3:
                value = deleteFront(&q);
                if (value != -1) {
                    printf("Deleted from front: %d\n", value);
                }
                break;
            case 4:
                value = deleteRear(&q);
                if (value != -1) {
                    printf("Deleted from rear: %d\n", value);
                }
                break;
            case 5:
                displayqueue(&q);
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}

6. Djikstra List
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>

struct AdjListNode {
    int dest;
    int weight;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct Graph {
    int V;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest, int weight) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest, int weight) {
    struct AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;
    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

struct MinHeapNode {
    int v;
    int dist;
};

struct MinHeap {
    int size;
    int capacity;
    int* pos;
    struct MinHeapNode** array;
};

struct MinHeapNode* newMinHeapNode(int v, int dist) {
    struct MinHeapNode* minHeapNode = (struct MinHeapNode*)malloc(sizeof(struct MinHeapNode));
    minHeapNode->v = v;
    minHeapNode->dist = dist;
    return minHeapNode;
}

struct MinHeap* createMinHeap(int capacity) {
    struct MinHeap* minHeap = (struct MinHeap*)malloc(sizeof(struct MinHeap));
    minHeap->pos = (int*)malloc(capacity * sizeof(int));
    minHeap->size = 0;
    minHeap->capacity = capacity;
    minHeap->array = (struct MinHeapNode*)malloc(capacity * sizeof(struct MinHeapNode));
    return minHeap;
}

void swapMinHeapNode(struct MinHeapNode** a, struct MinHeapNode** b) {
    struct MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}

void minHeapify(struct MinHeap* minHeap, int idx) {
    int smallest, left, right;
    smallest = idx;
    left = 2 * idx + 1;
    right = 2 * idx + 2;

    if (left < minHeap->size && minHeap->array[left]->dist < minHeap->array[smallest]->dist)
        smallest = left;

    if (right < minHeap->size && minHeap->array[right]->dist < minHeap->array[smallest]->dist)
        smallest = right;

    if (smallest != idx) {
        struct MinHeapNode* smallestNode = minHeap->array[smallest];
        struct MinHeapNode* idxNode = minHeap->array[idx];

        minHeap->pos[smallestNode->v] = idx;
        minHeap->pos[idxNode->v] = smallest;

        swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);

        minHeapify(minHeap, smallest);
    }
}

bool isEmpty(struct MinHeap* minHeap) {
    return minHeap->size == 0;
}

struct MinHeapNode* extractMin(struct MinHeap* minHeap) {
    if (isEmpty(minHeap))
        return NULL;

    struct MinHeapNode* root = minHeap->array[0];

    struct MinHeapNode* lastNode = minHeap->array[minHeap->size - 1];
    minHeap->array[0] = lastNode;

    minHeap->pos[root->v] = minHeap->size - 1;
    minHeap->pos[lastNode->v] = 0;

    --minHeap->size;
    minHeapify(minHeap, 0);

    return root;
}

void decreaseKey(struct MinHeap* minHeap, int v, int dist) {
    int i = minHeap->pos[v];
    minHeap->array[i]->dist = dist;
    while (i && minHeap->array[i]->dist < minHeap->array[(i - 1) / 2]->dist) {
        minHeap->pos[minHeap->array[i]->v] = (i - 1) / 2;
        minHeap->pos[minHeap->array[(i - 1) / 2]->v] = i;
        swapMinHeapNode(&minHeap->array[i], &minHeap->array[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

bool isInMinHeap(struct MinHeap* minHeap, int v) {
    return minHeap->pos[v] < minHeap->size;
}

void printArr(int dist[], int n) {
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t->\t %d\n", i, dist[i]);
}

void dijkstra(struct Graph* graph, int src) {
    int V = graph->V;
    int dist[V];
    struct MinHeap* minHeap = createMinHeap(V);

    for (int v = 0; v < V; ++v) {
        dist[v] = INT_MAX;
        minHeap->array[v] = newMinHeapNode(v, dist[v]);
        minHeap->pos[v] = v;
    }

    minHeap->array[src] = newMinHeapNode(src, dist[src]);
    minHeap->pos[src] = src;
    dist[src] = 0;
    decreaseKey(minHeap, src, dist[src]);
    minHeap->size = V;

    while (!isEmpty(minHeap)) {
        struct MinHeapNode* minHeapNode = extractMin(minHeap);
        int u = minHeapNode->v;
        struct AdjListNode* pCrawl = graph->array[u].head;
        while (pCrawl != NULL) {
            int v = pCrawl->dest;
            if (isInMinHeap(minHeap, v) && dist[u] != INT_MAX && pCrawl->weight + dist[u] < dist[v]) {
                dist[v] = dist[u] + pCrawl->weight;
                decreaseKey(minHeap, v, dist[v]);
            }
            pCrawl = pCrawl->next;
        }
    }

    printArr(dist, V);
}

int main() {
    int numNodes,numEdges;
     printf("Enter the number of vertices and edges in the graph: ");
    scanf("%d %d", &numNodes, &numEdges);
    struct Graph* graph = createGraph(numNodes);    

    printf("Enter the edges (source node, destination node, distance):\n");
    for (int i = 0; i < numEdges; ++i) {
        int src, dest, dist;
        scanf("%d %d %d", &src, &dest, &dist);
        addEdge(graph, src, dest, dist);
    }
    //source is set to 0
    dijkstra(graph, 0);

    return 0;
}

7. Djikstra Matrix

#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#define V 9

int minDistance(int dist[], bool sptSet[]) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

void printSolution(int dist[]) {
    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++)
        printf("%d \t\t %d\n", i, dist[i]);
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet);

        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    printSolution(dist);
}

int main() {
    int graph[V][V], n;

    printf("No. of vertices:");
    scanf("%d", &n);

    printf("\nEnter cost matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &graph[i][j]);
            if (graph[i][j] == 0)
                graph[i][j] = 999;
        }
    }

    dijkstra(graph, 0);

    return 0;
}

8. fibonacci
#include <stdio.h>

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n, i;

    printf("Enter the number of terms: ");
    scanf("%d", &n);

    printf("Fibonacci Series: ");
    for (i = 0; i < n; i++) {
        printf("%d ", fibonacci(i));
    }
    printf("\n");

    return 0;
}

9. infix to postfix
#include<stdio.h>
#include<ctype.h>

char stack[100];
int top = -1;

void push(char x)
{
    stack[++top] = x;
}

char pop()
{
    if(top == -1)
        return -1;
    else
        return stack[top--];
}

int priority(char x)
{
    if(x == '(')
        return 0;
    if(x == '+' || x == '-')
        return 1;
    if(x == '*' || x == '/')
        return 2;
    return 0;
}

int main()
{
    char exp[100];
    char *e, x;
    printf("Enter the expression : ");
    scanf("%s",exp);
    printf("\n");
    e = exp;    

    while(*e != '\0')
    {
        if(isalnum(*e))
            printf("%c ",*e);
        else if(*e == '(')
            push(*e);
        else if(*e == ')')
        {
            while((x = pop()) != '(')
                printf("%c ", x);
        }
        else
        {
            while(priority(stack[top]) >= priority(*e))
                printf("%c ",pop());
            push(*e);
        }
        e++;
    }

    while(top != -1)
    {
        printf("%c ",pop());
    }return 0;
}
    
10. infix to prefix

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#define MAX 100
char infix[MAX], prefix[MAX];

char stack[MAX];
int top = -1;

void push(char x) {
    if (top == MAX - 1) {
        printf("Stack overflow\n");
        exit(1);
    }
    stack[++top] = x;
}

char pop() {
    if (top == -1) {
        printf("Stack underflow\n");
        exit(1);
    }
    return stack[top--];
}

int priority(char x) {
    if (x == '(')
        return 0;
    if (x == '+' || x == '-')
        return 1;
    if (x == '*' || x == '/')
        return 2;
    if (x == '^')
        return 3;
    return 0;
}

void reverse(char *exp) {
    int n = strlen(exp);
    for (int i = 0; i < n / 2; i++) {
        char temp = exp[i];
        exp[i] = exp[n - i - 1];
        exp[n - i - 1] = temp;
    }
}

void infixToPrefix(char infix[], char prefix[]) {
    reverse(infix);
    int i = 0, k = 0;
    char x;
    while (infix[i] != '\0') {
        if (isalnum(infix[i])) {
            prefix[k++] = infix[i];
        } else if (infix[i] == ')') {
            push(infix[i]);
        } else if (infix[i] == '(') {
            while ((x = pop()) != ')') {
                prefix[k++] = x;
            }
        } else {
            while (top != -1 && priority(stack[top]) > priority(infix[i])) {
                prefix[k++] = pop();
            }
            push(infix[i]);
        }
        i++;
    }
    while (top != -1) {
        prefix[k++] = pop();
    }
    prefix[k] = '\0';
    reverse(prefix);
}

int main() 
{
    printf("Enter the infix expression: ");
    scanf("%s", infix);
    infixToPrefix(infix, prefix);
    printf("Prefix expression: %s\n", prefix);
    return 0;
}

11.kruskal List
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>

struct Edge {
    int src, dest, weight;
};

struct AdjListNode {
    int dest, weight;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct GraphList {
    int numNodes;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest, int weight) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

struct GraphList* createGraphList(int numNodes) {
    struct GraphList* graph = (struct GraphList*)malloc(sizeof(struct GraphList));
    graph->numNodes = numNodes;
    graph->array = (struct AdjList*)malloc(numNodes * sizeof(struct AdjList));
    for (int i = 0; i < numNodes; ++i)
        graph->array[i].head = NULL;
    return graph;
}

void addEdge(struct GraphList* graph, int src, int dest, int weight) {
    struct AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

struct Subset {
    int parent;
    int rank;
};

int find(struct Subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

void Union(struct Subset subsets[], int x, int y) {
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;
    else {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}

int compare(const void* a, const void* b) {
    struct Edge* edge1 = (struct Edge*)a;
    struct Edge* edge2 = (struct Edge*)b;
    return edge1->weight - edge2->weight;
}

void KruskalMST(struct GraphList* graph) {
    int numNodes = graph->numNodes;
    struct Edge result[numNodes];
    int e = 0;

    int i = 0;
    struct Edge* edges = (struct Edge*)malloc(numNodes * sizeof(struct Edge));
    for (int u = 0; u < numNodes; u++) {
        struct AdjListNode* temp = graph->array[u].head;
        while (temp != NULL) {
            if (temp->dest > u) {
                edges[i].src = u;
                edges[i].dest = temp->dest;
                edges[i].weight = temp->weight;
                i++;
            }
            temp = temp->next;
        }
    }
    qsort(edges, i, sizeof(edges[0]), compare);

    struct Subset* subsets = (struct Subset*)malloc(numNodes * sizeof(struct Subset));
    for (int v = 0; v < numNodes; ++v) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    i = 0;
    while (e < numNodes - 1 && i < numNodes) {
        struct Edge nextEdge = edges[i++];

        int x = find(subsets, nextEdge.src);
        int y = find(subsets, nextEdge.dest);

        if (x != y) {
            result[e++] = nextEdge;
            Union(subsets, x, y);
        }
    }

    printf("Edge \tWeight\n");
    for (int j = 0; j < e; ++j)
        printf("%d - %d  ->%d \n", result[j].src, result[j].dest, result[j].weight);
}

int main() {
    int numNodes, numEdges;
    printf("Enter the number of vertices and edges in the graph: ");
    scanf("%d %d", &numNodes, &numEdges);

    struct GraphList* graph = createGraphList(numNodes);

    printf("Enter the edges (source node, destination node, weight):\n");
    for (int i = 0; i < numEdges; ++i) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(graph, src, dest, weight);
    }
    printf("\nMST\n");

    KruskalMST(graph);

    return 0;
}

12. kruskal Matrix
#include <stdio.h>
#include <stdlib.h>

#define m 10

struct Graph
{
    int matrix[m][m];
    int V;
};

void init(struct Graph *g, int v)
{
    g->V = v;
    for (int i = 0; i < v; i++)
    {
        for (int j = 0; j < v; j++)
            g->matrix[i][j] = 999;
    }
}

void addEdgesMatrix(struct Graph *g, int a, int b,int k)
{
    if (a >= 0 && a < g->V && b >= 0 && b < g->V)
    {
        g->matrix[a][b] = k;
        g->matrix[b][a] = k;
    }
    else
    {
        printf("Invalid node indices!\n");
    }
}


int parent[m];

int findparent(int i) {
    while (parent[i] != i) {
        i = parent[i];
    }
    return i;
}

void union1(int i, int j) {
    int a = findparent(i);
    int b = findparent(j);
    parent[a] = b;
}

void KruskalMatrix(struct Graph* g) {
    int min = 999, n = 1, a, b;
    int minweight = 0;

    for (int i = 0; i < g->V; i++) {
        parent[i] = i;
    }

    while (n < g->V ) { 
        min = 999;
        for (int i = 0; i < g->V; i++) {
            for (int j = 0; j < g->V; j++) {
                if (g->matrix[i][j] < min && findparent(i) != findparent(j)) {
                    a = i;
                    b = j;
                    min = g->matrix[i][j];
                }
            }
        }

        union1(a, b);
        printf("%d %d \t-> %d\n", a, b, min);
        minweight = minweight + min;
        n++;
    }
    //  printf("Weight of MST: %d\n", minweight);
}

void Print(struct Graph *g)
{
   
    for (int i = 0; i < g->V; i++)
    {
        for (int j = 0; j < g->V; j++)
        {
            printf("%d ", g->matrix[i][j]);
        }
        printf("\n");
    }
}



int main() {
     struct Graph *g =  (struct Graph *)malloc(sizeof(struct Graph));
     int v,a,b,w,e,ch;
    printf("No. of Vertices: ");
    scanf("%d", &v);
    init(g,v);
    printf("No. of Edges: ");
    scanf("%d", &e);

    printf("Enter Edge (src,dest,weight):\n");
    for (int i = 0; i < e; i++) {
        scanf("%d %d %d", &a, &b, &w);
        addEdgesMatrix(g,a,b,w);
    }
     printf("\nMST\n");
        KruskalMatrix(g);
    return 0;
}

14.linear probing with replacment
#include <stdio.h>
#include <stdlib.h>

#define N 10

typedef struct Node {
    int key;
    struct Node* next;
} Node;

Node* hashTable[N];

int hash(int key) {
    return key % N;
}

Node* createNode(int key) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = NULL;
    return newNode;
}

void insert(int key) {
    int index = hash(key);
    Node* newNode = createNode(key);

    if (hashTable[index] == NULL) {
        hashTable[index] = newNode;
    } else {
        if (hash(hashTable[index]->key) != index) {
            // Replace and reinsert the displaced key
            Node* displacedNode = hashTable[index];
            hashTable[index] = newNode;
            insert(displacedNode->key);
            free(displacedNode); // Free the memory of displaced node
        } else {
            // Collision resolution using chaining
            int originalIndex = index;
            int i = 1;
            while (hashTable[(originalIndex + i) % N] != NULL && hashTable[(originalIndex + i) % N]->key != key) {
                index = (originalIndex + i) % N;
                i++;
            }
            if (hashTable[index] == NULL) {
                hashTable[index] = newNode;
            } else {
                Node* temp = hashTable[index];
                while (temp->next != NULL) {
                    temp = temp->next;
                }
                temp->next = newNode;
            }
        }
    }
}

void display() {
    for (int i = 0; i < N; i++) {
        printf("Index %d: ", i);
        Node* temp = hashTable[i];
        while (temp != NULL) {
            printf("%d -> ", temp->key);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}

int main() {
    // Initialize hash table with NULL values
    for (int i = 0; i < N; i++) {
        hashTable[i] = NULL;
    }

    insert(10);
    insert(20);
    insert(30);
    insert(40);
    insert(15);
    insert(25);
    insert(35);
    insert(45);
    insert(55);
    insert(65);

    printf("Hash table entries are:\n");
    display();

    return 0;
}

15.Linear probling without replacment
#include <stdio.h>

int tableSize = 10;
int collisions = 0;

void hashingWithoutReplacement(int arr[], int table[][2])
{
	for (int i = 0; i < 8; i++)
	{
		int index = arr[i] % tableSize;
		if (table[index][0] == -1)
		{
			table[index][0] = arr[i];
		}
		else
		{
			collisions++;
			int pos = index;
			int chain = -1;
			while (table[pos][0] != -1)
			{
				if (table[pos][0] % tableSize == index)
				{
					chain = pos;
				}
				pos = (pos + 1) % tableSize;
			}
			table[pos][0] = arr[i];
			if (chain != -1)
			{
				table[chain][1] = pos;
			}
		}
	}
}

void display(int table[][2])
{
	printf("Index\tValue\tChain\n");
	for (int i = 0; i < tableSize; i++)
	{
		printf("%d\t%d\t%d\n", i, table[i][0], table[i][1]);
	}
	printf("Number of collisions = %d\n", collisions);
}

int main()
{
	int arr[8] = {11, 101, 88, 18, 48, 3, 70, 19};	
	int table[tableSize][2];

	for (int i = 0; i < tableSize; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			table[i][j] = -1;
		}
	}

	hashingWithoutReplacement(arr, table);
	display(table);

	return 0;
}

16. polynomial add
#include<stdio.h>
#include<stdlib.h>

typedef struct poly
{
    int coeff;
    int exp;
    struct poly *next;
}poly;

poly* add(poly*,poly*);
void display(poly*);
poly* acceptPoly(int );

poly* acceptPoly(int n)
{
    poly *p,*head;
    p = head = (poly*)malloc(sizeof(poly));
    p->next = NULL;
    printf("\nEnter coefficient and expo :");
    scanf("%d%d",&p->coeff,&p->exp);
    for(int i=0;i<n-1;i++)
    {
        p->next = (poly*)malloc(sizeof(poly));
        p = p->next;
        p->next = NULL;
        printf("\nEnter coefficient and expo :");
        scanf("%d%d", &p->coeff,&p->exp);
    }
    printf("\n\n");
    return head;
}

poly* add(poly *p1,poly *p2)
{
    poly *p3,*head3;
    head3 = NULL;
    while(p1 != NULL && p2 != NULL)
    {
        if(head3 == NULL)
        {
            p3 = head3 = (poly*)malloc(sizeof(poly));
            p3->next = NULL;
        }
        else
        {
            p3->next = (poly*)malloc(sizeof(poly));
            p3 = p3->next;
            p3->next = NULL;
        }
        if(p1->exp == p2->exp)
        {
            p3->coeff = p1->coeff + p2->coeff;
            p3->exp = p1->exp;
            p1 = p1->next;
            p2 = p2->next;
        }
        else if(p1->exp > p2->exp)
        {
            p3->exp = p1->exp;
            p3->coeff = p1->coeff;
            p1 = p1->next;
        }
        else
        {
            p3->exp = p2->exp;
            p3->coeff = p2->coeff;
            p2 = p2->next;
        }
    }
    while(p1 != NULL)
    {
        if(head3 == NULL)
        {
            p3 = head3 = (poly*)malloc(sizeof(poly));
            p3->next = NULL;
        }
        else
        {
            p3->next = (poly*)malloc(sizeof(poly));
            p3 = p3->next;
            p3->next = NULL;
        }
        p3->exp = p1->exp;
        p3->coeff = p1->coeff;
        p1 = p1->next;
        p3 = p3->next;
    }
    while(p2 != NULL)
    {
        if(head3 == NULL)
        {
            p3 = head3 = (poly*)malloc(sizeof(poly));
            p3->next = NULL;
        }
        else
        {
            p3->next = (poly*)malloc(sizeof(poly));
            p3 = p3->next;
            p3->next = NULL;
        }
        p3->exp = p2->exp;
        p3->coeff = p2->coeff;
        p2 = p2->next;
        p3 = p3->next;
    }
    return head3;
}

void display(poly *p)
{
    poly *temp;
    temp = p;
    while(temp != NULL)
    {
        if(temp->exp == 0)
        printf("%d",temp->coeff);
        else if(temp->next == NULL)
        printf("%dx^%d",temp->coeff,temp->exp);
        else
        printf("%dx^%d +",temp->coeff,temp->exp);
        temp = temp->next;
    }
}

int main()
{
    poly *p1,*p2,*p3;
    int n1,n2;
    printf("Enter number of terms in Polynomail-1 and Polynimail-2");
    scanf("%d%d",&n1,&n2);
    p1 = acceptPoly(n1);
    p2 = acceptPoly(n2);
    p3 = add(p1,p2);
    display(p3);
    return 0;
}

17. prims List
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_int 100

struct Node {
    int data;
    int weight;
    struct Node* next;
};

struct Graph {
    struct Node* array[MAX_int];
};

int minDist(int dist[], bool visit[], int number) {
    int min = 999, min_index;
    for (int v=0; v<number; v++) {
        if (!visit[v] && dist[v] < min) {
            min = dist[v];
            min_index = v;
        }
    }
    return min_index;
}

void printMST(int parent[], int num, int G[MAX_int][MAX_int]) {
    printf("Edge \tWeight\n");
    for (int i = 1; i < num; i++)
        printf("%d - %d \t%d \n", parent[i], i, G[i][parent[i]]);
}

void primMSTMatrix(int G[MAX_int][MAX_int], int num) {
    int parent[MAX_int];
    int dist[MAX_int];
    bool visit[MAX_int];

    for (int i=0; i<num; i++) {
        dist[i] = 999;
        visit[i] = false;
        parent[i] = -1;
    }

    dist[0] = 0;

    for (int count=0; count<num-1; count++) {

        int u = minDist(dist, visit, num);

        visit[u] = true;

        for (int v=0; v<num; v++) {
            if (G[u][v] && !visit[v] && G[u][v] < dist[v]) {
                parent[v] = u;
                dist[v] = G[u][v];
            }
        }
    }

    printMST(parent, num, G);
}

void primMSTList(struct Graph* graph, int num) {
    int parent[MAX_int];
    int dist[MAX_int];
    bool visit[MAX_int];

    for (int i=0; i<num; i++) {
        dist[i] = 999;
        visit[i] = false;
        parent[i] = -1;
    }

    dist[0] = 0;

    for (int count=0; count<num-1; count++) {
        int u = minDist(dist, visit, num);
        visit[u] = true;

        struct Node* temp = graph -> array[u];
        while (temp != NULL) {
            int v = temp -> data;
            if (!visit[v] && temp -> weight < dist[v]) {
                parent[v] = u;
                dist[v] = temp -> weight;
            }
            temp = temp->next;
        }
    }

    printf("Edge \tWeight\n");
    for (int i=1; i<num; i++) {
        printf("%d - %d \t%d \n", parent[i], i, dist[i]);
    }
}

struct Node* createNode(int data, int weight) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode -> data = data;
    newNode -> weight = weight;
    newNode -> next = NULL;
    return newNode;
}

struct Graph* createGraph(int num) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    for (int i=0; i<num; i++)
        graph -> array[i] = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest, int weight) {
    struct Node* newNode = createNode(dest, weight);
    newNode -> next = graph -> array[src];
    graph -> array[src] = newNode;

    newNode = createNode(src, weight);
    newNode -> next = graph -> array[dest];
    graph -> array[dest] = newNode;
}

int main() {
    int num, edges;
    printf("Enter the number of nodes and edges in the graph: ");
    scanf("%d %d", &num, &edges);

    int G[MAX_int][MAX_int] = {0};
    struct Graph* graph = createGraph(num);

    printf("Enter the edges:\n");
    for (int i=0; i<edges; i++) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        G[src][dest] = G[dest][src] = weight;
        addEdge(graph, src, dest, weight);
    }

    int choice;
    do {
        printf("\nMenu:\n");
        printf("1. Prim's using matrix\n");
        printf("2. Prim's using list\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Minimum Spanning Tree using adjacency matrix:\n");
                primMSTMatrix(G, num);
                break;
            case 2:
                printf("Minimum Spanning Tree using adjacency list:\n");
                primMSTList(graph, num);
                break;
            case 3:
                printf("Exiting\n");
                break;
            default:
                printf("Invalid choice\n");
        }
    } while (choice != 3);

    return 0;
}

18. prims matrix
#include<stdio.h>
#include<stdlib.h>

void prims(int [][10],int);
int FindMinDist(int [],int [],int);
void DisplayMST(int [],int [][10],int);

void prims(int G[][10],int V)
{
    int visited[10],distance[10],parent[10],u;
    for(int i=0;i<V;i++)
    {
        visited[i] = 0;
        distance[i] = 999;
        parent[i] = -1;
    }
    distance[0] = 0;
    for(int i=0;i<(V-1);i++)
    {
        i = FindMinDist(distance,visited,V);
        visited[u] = 1;
        for(int j=0;j<V;j++)
        {
            if(G[u][j] != 999 && visited[j] == 0 && distance[j]>G[u][j])
            {
                distance[j] = G[u][j];
                parent[j] = u;
            }
        }
    }
    DisplayMST(parent,G,V);
}

int FindMinDist(int distance[], int visited[],int V)
{
    int index,min = 999;
    for(int i=0;i<V;i++)
    {
        if(visited[i] == 0 && distance[i]<min)
        {
            min = distance[i];
            index = i;
        }
    }
    return index;
}

void DisplayMST(int parent[],int G[][10],int V)
{
    printf("\nPrim's MST, Edge \t weight\n");
    for(int i=0;i<V;i++)
    {
        printf("Edge: %d %d, weight:- %d",i,parent[i],G[i][parent[i]]);
    }
}

int main()
{
    int G[10][10],V,e,u,v,ch;
    printf("Enter number of vertex");
    scanf("%d",&V);
    for(int i=0;i<V;i++)
    {
        for(int j=0;j<V;j++)
            G[i][j] = 0;
    }
    printf("\nEnter number of edges");
    scanf("%d",&e);
    for(int i=0;i<e;i++)
    {
        printf("\nEnter Edge: ");
        scanf("%d%d",&u,&v);
        G[u][v] = G[v][u] = 1;
    }
    prims(G,V);
    return 0;
}

19. reverse list
#include<stdio.h>
#include<stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
}node;

node* reverse(node*);
node* create(node*);
node* insert(node*,int);
void display(node *);

node* create(node *root)
{
    int ch,n;
    do
    {
        printf("\n1)Add\n2)Exit");
        printf("\n\nEnter choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: printf("\nEnter number");
                    scanf("%d",&n);
                    root = insert(root,n);
                    break;
            case 2: break;
            default:printf("\nWrong Input");
                    break;
        }
    }while(ch != 2);
    return root;
}

node* insert(node *root, int n)
{
    node *temp;
    temp = root;
    if(root == NULL)
    {
        root = (node*)malloc(sizeof(node));
        root->data = n;
        root->next = NULL;
        return root;
    }
    else
    {
        while(temp->next != NULL)
        {
            temp = temp->next;
        }
        temp->next = (node*)malloc(sizeof(node));
        temp = temp->next;
        temp->data = n;
        temp->next = NULL;
    }
    return root;
}

node* reverse(node *root)
{
    node *head,*curr = root,*prev = NULL,*next = NULL;
    while(curr != NULL)
    {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    head = prev;
    return head;
}

void display(node *root)
{
    node *temp = root;
    while(temp != NULL)
    {
        printf("%d ",temp->data);
        temp = temp->next;
    }
}

int main()
{
    node *root = NULL;
    int ch,n;
    do
    {
        printf("\n1)Create\n2)Insert\n3)Reverse\n4)Display\n5)Exit");
        printf("\nEnter choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: root = create(root);
                    break;
            case 2: printf("\n\nEnter Number");
                    break;
            case 3: root = reverse(root);
                    break;
            case 4: display(root);
                    break;
            case 5: break;
            default:printf("\n\nWrong choice");
                    break;
        }
    }while(ch != 5);
    free(root);
    return 0;
}

20. tbt
#include<stdio.h>
#include<stdlib.h>

typedef struct tbt_node
{
    int data,lbit,rbit;
    struct tbt_node *left,*right;
}tbt_node;

tbt_node* tbt_create(tbt_node*);
tbt_node* tbt_insert(tbt_node*,int);
void tbt_inorder(tbt_node*);
void tbt_preorder(tbt_node*);

void tbt_inorder(tbt_node *root)
{
    tbt_node *temp = root->left;
    while(temp->lbit == 1)
    temp = temp->left;
    while(temp != root)
    {
        printf("%d ",temp->data);
        if(temp->rbit == 0)
        temp = temp->right;
        else if(temp->rbit == 1)
        {
            temp = temp->right;
            while(temp->lbit == 1)
            temp = temp->left;
        }
    }
}

void tbt_preorder(tbt_node *root)
{
    tbt_node *temp = root->left;
    while (temp != root)
    {
        while (temp->lbit == 1)
        {
            printf("%d ", temp->data);
            temp = temp->left;
        }
        printf("%d ", temp->data);

        while (temp->rbit == 0 && temp->right != root)
        {
            temp = temp->right;
            if (temp == root)
                return;
        }

        temp = temp->right;
    }
}

tbt_node* tbt_create(tbt_node* root)
{
    int ch,n;
    do
    {
        printf("\n1)Add\n2)Exit");
        printf("\nEnter Choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: printf("\nEnter number");
                    scanf("%d",&n);
                    root = tbt_insert(root,n);
                    break;
            case 2: break;
            default:printf("\nWrong choice");
                    break;
        }
    }while(ch != 2);
    return root;
}

tbt_node* tbt_insert(tbt_node *root, int n)
{
    tbt_node *temp,*p;
    temp = (tbt_node*)malloc(sizeof(tbt_node));
    temp->data = n;
    temp->rbit = temp->lbit = 0;
    if(root->lbit == 0)
    {
        root->left = temp;
        root->lbit = 1;
        temp->left = temp->right = root;
        return root;
    }
    p = root->left;
    while(1)
    {
        if(n < p->data && p->lbit == 1)
        p = p->left;
        else if(n > p->data && p->rbit == 1)
        p = p->right;
        else
        break;
    }
    if(n < p->data)
    {
        temp->right = p;
        temp->left = p->left;
        p->left = temp;
        p->lbit = 1;
    }
    else
    {
        temp->left = p;
        temp->right = p->right;
        p->right = temp;
        p->rbit = 1;
    }
    return  root;
}

int main()
{
    int ch,n;
    tbt_node *root;
    root = (tbt_node*)malloc(sizeof(tbt_node));
    root->lbit = 0;
    root->right = root->left = root;
    root->rbit = 1;
    do
    {
        printf("\n\n1)Create\n2)Insert\n3)Inorder\n4)Preorder\n5)Exit");
        printf("\nEnter your choice: ");
        scanf("%d",&ch);
        switch(ch)
        {
            case 1: root = tbt_create(root);
                    break;
            case 2: printf("\nEnter number");
                    scanf("%d",&n);
                    root = tbt_insert(root,n);
                    break;
            case 3: tbt_inorder(root);
                    break;
            case 4: tbt_preorder(root);
                    break;
            case 5: break;
            default:printf("\nWrong Choice");
                    break;
        }
    }while(ch != 5);
    return 0;
}

